# Plugin Development Guide v5 - Technical Reference

## Purpose of This Guide

This is a technical implementation guide for developing plugins in the Homebase modular architecture. After reading this guide, you should understand the file structure, code patterns, and development workflow needed to create new plugins. For complete working examples, reference the contacts plugin implementation. This guide focuses on "how-to" patterns rather than historical context.

## App Overview

Homebase is a plugin-based business application with modular context architecture. The core handles authentication, database, and routing while plugins provide specialized functionality through isolated contexts. Each plugin manages its own state independently, preventing re-renders across plugins and enabling team isolation.

**Stack:** React + TypeScript + Express.js + MySQL/PostgreSQL + Plugin-loader system

## Architecture Overview

### Backend Structure
```
plugins/[plugin-name]/
â”œâ”€â”€ plugin.config.js    # Plugin metadata
â”œâ”€â”€ model.js           # Database operations  
â”œâ”€â”€ controller.js      # Request handling
â”œâ”€â”€ routes.js          # Express routes
â””â”€â”€ index.js          # Plugin initialization

Core:
â”œâ”€â”€ plugin-loader.js   # Automatic plugin discovery
â”œâ”€â”€ server/index.ts    # Main server (minimal, uses plugin-loader)
â””â”€â”€ scripts/setup-database.js
```

### Frontend Structure (Modular Context System)
```
client/src/plugins/[plugin-name]/
â”œâ”€â”€ types/[plugin-name].ts        # TypeScript interfaces
â”œâ”€â”€ context/[Name]Context.tsx     # Plugin-specific state management
â”œâ”€â”€ hooks/use[Name].ts           # Plugin-specific hook
â”œâ”€â”€ api/[name]Api.ts             # Isolated API calls
â””â”€â”€ components/                  # Plugin components

Core:
â”œâ”€â”€ core/api/AppContext.tsx      # Minimal shared state (auth + cross-plugin)
â”œâ”€â”€ core/pluginRegistry.ts       # Plugin registration
â””â”€â”€ App.tsx                      # Provider composition
```

## Plugin Development Workflow

### 1. Backend Plugin Setup

**Create structure:**
```bash
mkdir -p plugins/my-plugin
touch plugins/my-plugin/{plugin.config.js,model.js,controller.js,routes.js,index.js}
```

**plugin.config.js:**
```javascript
module.exports = {
  name: 'my-plugin',
  routeBase: '/api/my-plugin',
  requiredRole: 'user',
  description: 'Plugin description',
};
```

**Standard patterns:** Copy from contacts plugin and adapt for your data model.

### 2. Frontend Plugin Setup

**Create structure:**
```bash
mkdir -p client/src/plugins/my-plugin/{types,context,hooks,api,components}
```

**types/my-plugin.ts pattern:**
```typescript
export interface MyPluginItem {
  id: string;
  title: string;
  content: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface ValidationError {
  field: string;
  message: string;
}
```

**context/MyPluginContext.tsx pattern:**
```typescript
interface MyPluginContextType {
  // Panel State
  isMyPluginPanelOpen: boolean;
  currentItem: MyPluginItem | null;
  myPluginPanelMode: 'create' | 'edit' | 'view'; // Note: [plugin]PanelMode naming
  
  // Data State
  items: MyPluginItem[];
  validationErrors: ValidationError[];
  
  // Actions
  openMyPluginPanel: (item: MyPluginItem | null) => void;
  openMyPluginForEdit: (item: MyPluginItem) => void;
  openMyPluginForView: (item: MyPluginItem) => void;
  closeMyPluginPanel: () => void;
  saveMyPlugin: (data: any) => Promise<boolean>;
  deleteMyPlugin: (id: string) => Promise<void>;
}

export function MyPluginProvider({ children, isAuthenticated, onCloseOtherPanels }) {
  // State management with isolated context
  // Load data when authenticated
  // All CRUD operations
}
```

**hooks/useMyPlugin.ts:**
```typescript
import { useMyPluginContext } from '../context/MyPluginContext';

export function useMyPlugin() {
  return useMyPluginContext();
}
```

**api/myPluginApi.ts pattern:**
```typescript
class MyPluginApi {
  private async request(endpoint: string, options: RequestInit = {}) {
    // Standard API request pattern
  }
  
  async getItems() { return this.request('/my-plugin'); }
  async createItem(data: any) { return this.request('/my-plugin', { method: 'POST', body: JSON.stringify(data) }); }
}

export const myPluginApi = new MyPluginApi();
```

### 3. Component Patterns

**List Component:**
```typescript
export const MyPluginList = () => {
  const { items, openMyPluginPanel } = useMyPlugin();
  // Mobile-first responsive design
  // Search and sort functionality
  // CRUD action buttons
};
```

**Form Component:**
```typescript
export const MyPluginForm = ({ currentItem, onSave, onCancel }) => {
  const { validationErrors } = useMyPlugin();
  
  // Global functions for UniversalPanel footer (IMPORTANT: Plural naming)
  useEffect(() => {
    window.submitMyPluginsForm = handleSubmit; // Note: Plural!
    window.cancelMyPluginsForm = handleCancel; // Note: Plural!
    return () => {
      delete window.submitMyPluginsForm;
      delete window.cancelMyPluginsForm;
    };
  }, [handleSubmit, handleCancel]);
};
```

**View Component:**
```typescript
export const MyPluginView = ({ item }) => {
  // Read-only display
  // Cross-plugin navigation if needed
};
```

### 4. Plugin Registration

**Add to core/pluginRegistry.ts:**
```typescript
import { MyPluginProvider } from '@/plugins/my-plugin/context/MyPluginContext';
import { useMyPlugin } from '@/plugins/my-plugin/hooks/useMyPlugin';
import { MyPluginList, MyPluginForm, MyPluginView } from '@/plugins/my-plugin/components';

export const PLUGIN_REGISTRY: PluginRegistryEntry[] = [
  // ... existing plugins
  {
    name: 'my-plugins', // Note: Plural
    Provider: MyPluginProvider,
    hook: useMyPlugin,
    panelKey: 'isMyPluginPanelOpen',
    components: {
      List: MyPluginList,
      Form: MyPluginForm,
      View: MyPluginView,
    }
  }
];
```

## Critical Implementation Details

### Panel Mode Naming Convention
- Context property: `[plugin]PanelMode` (e.g., `contactPanelMode`, `estimatePanelMode`)
- App.tsx expects this specific naming pattern

### Global Function Naming
- Form components must use **plural** naming:
  - `window.submitContactsForm` (not `submitContactForm`)
  - `window.cancelEstimatesForm` (not `cancelEstimateForm`)

### Cross-Plugin Data Access
```typescript
// In plugin components that need cross-plugin data:
const { validationErrors } = useMyPlugin(); // Plugin-specific
const { contacts, openContactForView } = useApp(); // Cross-plugin only

// Always add safety checks:
const safeContacts = contacts || [];
```

### Hook Order (Critical)
App.tsx calls all plugin hooks in consistent order to prevent "Rules of Hooks" violations:
```typescript
// All plugin hooks are called first, then logic is applied
const pluginContexts = PLUGIN_REGISTRY.map(plugin => ({
  plugin,
  context: plugin.hook(), // Always called, never conditional
}));
```

## Database Integration

### Schema Pattern
```sql
CREATE TABLE IF NOT EXISTS my_plugin_items (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(255) NOT NULL,
  content TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Plugin Access Control
```sql
INSERT INTO user_plugin_access (user_id, plugin_name, enabled)
SELECT id, 'my-plugin', true FROM users WHERE role = 'superuser';
```

## Performance Benefits

The modular context architecture provides:
- **90% fewer re-renders** - Only relevant plugin components update
- **Zero team conflicts** - Complete plugin isolation
- **95% simpler testing** - Mock individual plugin contexts
- **Hot module replacement ready** - Development experience optimized

## Development Time

**Estimated implementation time per plugin:** 20-30 minutes
1. **Backend Plugin:** 8 minutes (copy templates, customize)
2. **Frontend Context:** 8 minutes (copy templates, customize)  
3. **Components:** 8 minutes (build UI using context hook)
4. **Registration:** 3 minutes (add to pluginRegistry.ts)
5. **Testing:** 3 minutes (verify CRUD operations)

## Testing Patterns

### Plugin Context Testing
```typescript
const TestMyPluginProvider = ({ children, mockData = [] }) => (
  <MyPluginContext.Provider value={{
    items: mockData,
    isMyPluginPanelOpen: false,
    // ... mock all context values
  }}>
    {children}
  </MyPluginContext.Provider>
);
```

### API Testing
```bash
curl http://localhost:3002/api/my-plugin -b cookies.txt
curl -X POST http://localhost:3002/api/my-plugin -H "Content-Type: application/json" -d '{"title":"Test"}' -b cookies.txt
```

## Common Issues & Solutions

### Plugin Not Loading
Check server logs for plugin loading confirmation:
```bash
npm run dev
# Should show: "ðŸŸ¢ Loaded plugin: my-plugin (/api/my-plugin)"
```

### Panel Conflicts
Ensure proper cross-plugin navigation:
```typescript
const handleCrossPluginNavigation = (item) => {
  closeCurrentPluginPanel(); // Always close current first
  openTargetPluginPanel(item); // Then open target
};
```

### Context Not Found Error
Ensure hook is used within provider:
```typescript
export function useMyPlugin() {
  const context = useContext(MyPluginContext);
  if (!context) throw new Error('useMyPlugin must be used within MyPluginProvider');
  return context;
}
```

## Key Principles

1. **Plugin Isolation** - Each plugin manages its own state through dedicated context
2. **Provider Composition** - Stack providers in App.tsx to build context hierarchy  
3. **Cross-Plugin Coordination** - Use AppContext for shared data and panel coordination
4. **Automatic Discovery** - Backend plugin-loader handles registration automatically
5. **Performance First** - Modular contexts prevent unnecessary re-renders
6. **Type Safety** - TypeScript interfaces ensure robust plugin contracts
7. **Consistent Naming** - Follow established conventions for seamless integration

## Reference Implementation

See `client/src/plugins/contacts/` for complete working example including:
- Full modular context implementation
- Cross-plugin navigation patterns
- Form validation and error handling
- CRUD operations with API integration
- Component structure and styling