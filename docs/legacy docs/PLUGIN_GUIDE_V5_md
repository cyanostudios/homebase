# Plugin Development Guide v5 - Technical Reference

## Purpose of This Guide

This is a technical implementation guide for developing plugins in the Homebase modular architecture. After reading this guide, you should understand the file structure, code patterns, and development workflow needed to create new plugins. For complete working examples, reference the contacts plugin implementation. This guide focuses on "how-to" patterns rather than historical context.

## App Overview

Homebase is a plugin-based business application with modular context architecture and universal keyboard navigation. The core handles authentication, database, and routing while plugins provide specialized functionality through isolated contexts. Each plugin manages its own state independently, preventing re-renders across plugins and enabling team isolation.

**Stack:** React + TypeScript + Express.js + MySQL/PostgreSQL + Plugin-loader system + Universal Space Navigation

## Architecture Overview

### Backend Structure
```
plugins/[plugin-name]/
â”œâ”€â”€ plugin.config.js    # Plugin metadata
â”œâ”€â”€ model.js           # Database operations  
â”œâ”€â”€ controller.js      # Request handling
â”œâ”€â”€ routes.js          # Express routes
â””â”€â”€ index.js          # Plugin initialization

Core:
â”œâ”€â”€ plugin-loader.js   # Automatic plugin discovery
â”œâ”€â”€ server/index.ts    # Main server (minimal, uses plugin-loader)
â””â”€â”€ scripts/setup-database.js
```

### Frontend Structure (Modular Context System)
```
client/src/plugins/[plugin-name]/
â”œâ”€â”€ types/[plugin-name].ts        # TypeScript interfaces
â”œâ”€â”€ context/[Name]Context.tsx     # Plugin-specific state management
â”œâ”€â”€ hooks/use[Name].ts           # Plugin-specific hook
â”œâ”€â”€ api/[name]Api.ts             # Isolated API calls
â””â”€â”€ components/                  # Plugin components with keyboard navigation

Core:
â”œâ”€â”€ core/api/AppContext.tsx      # Minimal shared state (auth + cross-plugin)
â”œâ”€â”€ core/pluginRegistry.ts       # Plugin registration
â””â”€â”€ App.tsx                      # Provider composition + Universal Space handler
```

## Plugin Development Workflow

### 1. Backend Plugin Setup

**Create structure:**
```bash
mkdir -p plugins/my-plugin
touch plugins/my-plugin/{plugin.config.js,model.js,controller.js,routes.js,index.js}
```

**plugin.config.js:**
```javascript
module.exports = {
  name: 'my-plugin',
  routeBase: '/api/my-plugin',
  requiredRole: 'user',
  description: 'Plugin description',
};
```

**Standard patterns:** Copy from contacts plugin and adapt for your data model.

### 2. Frontend Plugin Setup

**Create structure:**
```bash
mkdir -p client/src/plugins/my-plugin/{types,context,hooks,api,components}
```

**types/my-plugin.ts pattern:**
```typescript
export interface MyPluginItem {
  id: string;
  title: string;
  content: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface ValidationError {
  field: string;
  message: string;
}
```

**context/MyPluginContext.tsx pattern:**
```typescript
interface MyPluginContextType {
  // Panel State
  isMyPluginPanelOpen: boolean;
  currentItem: MyPluginItem | null;
  myPluginPanelMode: 'create' | 'edit' | 'view'; // Note: [plugin]PanelMode naming
  
  // Data State
  items: MyPluginItem[];
  validationErrors: ValidationError[];
  
  // Actions
  openMyPluginPanel: (item: MyPluginItem | null) => void;
  openMyPluginForEdit: (item: MyPluginItem) => void;
  openMyPluginForView: (item: MyPluginItem) => void;
  closeMyPluginPanel: () => void;
  saveMyPlugin: (data: any) => Promise<boolean>;
  deleteMyPlugin: (id: string) => Promise<void>;
}

export function MyPluginProvider({ children, isAuthenticated, onCloseOtherPanels }) {
  // State management with isolated context
  // Load data when authenticated
  // All CRUD operations
}
```

**hooks/useMyPlugin.ts:**
```typescript
import { useMyPluginContext } from '../context/MyPluginContext';

export function useMyPlugin() {
  return useMyPluginContext();
}
```

**api/myPluginApi.ts pattern:**
```typescript
class MyPluginApi {
  private async request(endpoint: string, options: RequestInit = {}) {
    // Standard API request pattern
  }
  
  async getItems() { return this.request('/my-plugin'); }
  async createItem(data: any) { return this.request('/my-plugin', { method: 'POST', body: JSON.stringify(data) }); }
}

export const myPluginApi = new MyPluginApi();
```

### 3. Component Patterns with Keyboard Navigation

**List Component (with Universal Space support):**
```typescript
export const MyPluginList = () => {
  const { items, openMyPluginPanel, openMyPluginForView } = useMyPlugin();
  const [searchTerm, setSearchTerm] = useState('');
  const [isMobileView, setIsMobileView] = useState(false);
  
  // Mobile-first responsive design
  // Search functionality
  // IMPORTANT: Keyboard navigation support
  
  return (
    <div className="p-4 sm:p-8">
      {/* Header with search */}
      <div className="mb-6 sm:mb-8 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <Heading level={1}>My Plugin Items</Heading>
          <Text variant="caption">Manage your items</Text>
        </div>
        <div className="flex flex-col sm:flex-row gap-3 sm:items-center">
          {/* Search Controls */}
          <div className="relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-4 w-4" />
            <input
              type="text"
              placeholder="Search items..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-full sm:w-80 pl-10 pr-4 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
            />
          </div>
          <Button
            onClick={() => openMyPluginPanel(null)}
            variant="primary"
            icon={Plus}
          >
            Add Item
          </Button>
        </div>
      </div>

      {/* Table with keyboard navigation */}
      <Card>
        <table className="w-full">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Title
              </th>
              {/* More headers */}
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-200">
            {items.map((item, idx) => (
              <tr 
                key={item.id} 
                className={`${idx % 2 === 0 ? 'bg-white' : 'bg-gray-50'} hover:bg-blue-50 focus:bg-blue-100 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-inset cursor-pointer`}
                tabIndex={0}
                data-list-item={JSON.stringify(item)}
                data-plugin-name="my-plugins" // Note: Plural!
                role="button"
                aria-label={`Open ${item.title}`}
                onClick={() => openMyPluginForView(item)}
              >
                <td className="px-6 py-4 whitespace-nowrap">
                  <div className="text-sm font-medium text-gray-900">{item.title}</div>
                </td>
                {/* More cells */}
              </tr>
            ))}
          </tbody>
        </table>
      </Card>
    </div>
  );
};
```

**Form Component:**
```typescript
export const MyPluginForm = ({ currentItem, onSave, onCancel }) => {
  const { validationErrors } = useMyPlugin();
  
  // Global functions for UniversalPanel footer (IMPORTANT: Plural naming)
  useEffect(() => {
    window.submitMyPluginsForm = handleSubmit; // Note: Plural!
    window.cancelMyPluginsForm = handleCancel; // Note: Plural!
    return () => {
      delete window.submitMyPluginsForm;
      delete window.cancelMyPluginsForm;
    };
  }, [handleSubmit, handleCancel]);
};
```

**View Component:**
```typescript
export const MyPluginView = ({ item }) => {
  // Read-only display
  // Cross-plugin navigation if needed
};
```

### 4. Plugin Registration

**Add to core/pluginRegistry.ts:**
```typescript
import { MyPluginProvider } from '@/plugins/my-plugin/context/MyPluginContext';
import { useMyPlugin } from '@/plugins/my-plugin/hooks/useMyPlugin';
import { MyPluginList, MyPluginForm, MyPluginView } from '@/plugins/my-plugin/components';

export const PLUGIN_REGISTRY: PluginRegistryEntry[] = [
  // ... existing plugins
  {
    name: 'my-plugins', // Note: Plural
    Provider: MyPluginProvider,
    hook: useMyPlugin,
    panelKey: 'isMyPluginPanelOpen',
    components: {
      List: MyPluginList,
      Form: MyPluginForm,
      View: MyPluginView,
    }
  }
];
```

## Universal Keyboard Navigation (v7+ Feature)

### Automatic Space Navigation
All plugins automatically get keyboard navigation without additional code:

**User Experience:**
- **Tab** through table rows in any list
- **Space** on focused row = Opens item in view mode
- **Space** when panel is open = Closes panel
- **Visual feedback** with focus rings and hover states

**Implementation Requirements:**
Your List component must include these attributes on table rows:

```typescript
<tr
  tabIndex={0}                                    // Makes row focusable
  data-list-item={JSON.stringify(item)}         // Item data for Space handler
  data-plugin-name="my-plugins"                 // Plugin identifier (plural!)
  role="button"                                 // Accessibility
  aria-label={`Open ${item.title}`}            // Screen reader support
  className="hover:bg-blue-50 focus:bg-blue-100 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-inset cursor-pointer"
  onClick={() => openMyPluginForView(item)}    // Mouse support
>
```

**Color Coding:**
- **Contacts**: Blue theme (`hover:bg-blue-50 focus:bg-blue-100 focus:ring-blue-500`)
- **Notes**: Yellow theme (`hover:bg-yellow-50 focus:bg-yellow-100 focus:ring-yellow-500`)
- **Estimates**: Blue theme (`hover:bg-blue-50 focus:bg-blue-100 focus:ring-blue-500`)

### Safety Features
The universal Space handler automatically:
- âœ… Ignores Space in form inputs and textareas
- âœ… Prevents page scrolling conflicts
- âœ… Works across all plugins without configuration
- âœ… Provides consistent UX for accessibility

## Critical Implementation Details

### Panel Mode Naming Convention
- Context property: `[plugin]PanelMode` (e.g., `contactPanelMode`, `estimatePanelMode`)
- App.tsx expects this specific naming pattern

### Global Function Naming
- Form components must use **plural** naming:
  - `window.submitContactsForm` (not `submitContactForm`)
  - `window.cancelEstimatesForm` (not `cancelEstimateForm`)

### Cross-Plugin Data Access
```typescript
// In plugin components that need cross-plugin data:
const { validationErrors } = useMyPlugin(); // Plugin-specific
const { contacts, openContactForView } = useApp(); // Cross-plugin only

// Always add safety checks:
const safeContacts = contacts || [];
```

### Hook Order (Critical)
App.tsx calls all plugin hooks in consistent order to prevent "Rules of Hooks" violations:
```typescript
// All plugin hooks are called first, then logic is applied
const pluginContexts = PLUGIN_REGISTRY.map(plugin => ({
  plugin,
  context: plugin.hook(), // Always called, never conditional
}));
```

## Database Integration

### Schema Pattern
```sql
CREATE TABLE IF NOT EXISTS my_plugin_items (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(255) NOT NULL,
  content TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Plugin Access Control
```sql
INSERT INTO user_plugin_access (user_id, plugin_name, enabled)
SELECT id, 'my-plugin', true FROM users WHERE role = 'superuser';
```

## Performance Benefits

The modular context architecture provides:
- **90% fewer re-renders** - Only relevant plugin components update
- **Zero team conflicts** - Complete plugin isolation
- **95% simpler testing** - Mock individual plugin contexts
- **Hot module replacement ready** - Development experience optimized
- **Universal keyboard navigation** - Consistent UX across all plugins

## Development Time

**Estimated implementation time per plugin:** 15-25 minutes
1. **Backend Plugin:** 5 minutes (copy templates, customize)
2. **Frontend Context:** 5 minutes (copy templates, customize)  
3. **Components:** 8 minutes (build UI using context hook + keyboard nav)
4. **Registration:** 5 minutes (add to pluginRegistry.ts)
5. **Testing:** 2 minutes (verify CRUD operations + Space navigation)

## Testing Patterns

### Plugin Context Testing
```typescript
const TestMyPluginProvider = ({ children, mockData = [] }) => (
  <MyPluginContext.Provider value={{
    items: mockData,
    isMyPluginPanelOpen: false,
    // ... mock all context values
  }}>
    {children}
  </MyPluginContext.Provider>
);
```

### Keyboard Navigation Testing
```typescript
// Test Space key functionality
test('Space key opens item in view mode', () => {
  render(<MyPluginList />);
  const firstRow = screen.getByRole('button', { name: /open/i });
  firstRow.focus();
  fireEvent.keyDown(firstRow, { code: 'Space' });
  expect(mockOpenForView).toHaveBeenCalled();
});
```

### API Testing
```bash
curl http://localhost:3002/api/my-plugin -b cookies.txt
curl -X POST http://localhost:3002/api/my-plugin -H "Content-Type: application/json" -d '{"title":"Test"}' -b cookies.txt
```

## Common Issues & Solutions

### Plugin Not Loading
Check server logs for plugin loading confirmation:
```bash
npm run dev
# Should show: "ðŸŸ¢ Loaded plugin: my-plugin (/api/my-plugin)"
```

### Keyboard Navigation Not Working
Ensure table rows have required attributes:
```typescript
// Missing any of these will break Space navigation
tabIndex={0}
data-list-item={JSON.stringify(item)}
data-plugin-name="my-plugins" // Must be plural!
```

### Panel Conflicts
Ensure proper cross-plugin navigation:
```typescript
const handleCrossPluginNavigation = (item) => {
  closeCurrentPluginPanel(); // Always close current first
  openTargetPluginPanel(item); // Then open target
};
```

### Context Not Found Error
Ensure hook is used within provider:
```typescript
export function useMyPlugin() {
  const context = useContext(MyPluginContext);
  if (!context) throw new Error('useMyPlugin must be used within MyPluginProvider');
  return context;
}
```

## Key Principles

1. **Plugin Isolation** - Each plugin manages its own state through dedicated context
2. **Provider Composition** - Stack providers in App.tsx to build context hierarchy  
3. **Cross-Plugin Coordination** - Use AppContext for shared data and panel coordination
4. **Automatic Discovery** - Backend plugin-loader handles registration automatically
5. **Performance First** - Modular contexts prevent unnecessary re-renders
6. **Type Safety** - TypeScript interfaces ensure robust plugin contracts
7. **Consistent Naming** - Follow established conventions for seamless integration
8. **Universal Navigation** - Keyboard accessibility built-in for all plugins

## Reference Implementation

See `client/src/plugins/contacts/` for complete working example including:
- Full modular context implementation
- Universal keyboard navigation support
- Cross-plugin navigation patterns
- Form validation and error handling
- CRUD operations with API integration
- Component structure and styling
- Search functionality with responsive design